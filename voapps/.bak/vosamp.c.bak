/**
 *  VOSAMP - Example task to send a single SAMP message for the cmdline.
 *
 *  Usage:
 *
 *	vosamp [<opts>] <cmd> [args ...]
 *
 *  Where	
 *	<cmd>				command to process
 *  	-%,--test			run unit tests
 *  	-h,--help			print help summary
 *  	-d,--debug			debug output
 *  	-v,--verbose			verbose output
 *
 *  	-i,--interact			interactive mode
 *  	-m,--many			handle multiple messages
 *  	-s,--sender <sender>		handle only messages from <sender>
 *
 *  	-t,--to <to>			send to specified application (or all)
 *  	-p,--pattern <pattern>		message pattern:  sync|async|notify
 *  	-f,--file <file>		send all commands in the file
 *  	-k,--keepalive			disable keep_alive feature
 *
 *  	-P,--proxy <pattern>		message pattern:  sync|async|notify
 *  	-T,--timeout <N>		keepalive timeout
 *  	-S,--session <name>		session name
 *
 *	-r,--return			return result to API
 *
 *
 *  Subcommands:
 *
 *    snoop 				    print all received messages
 *
 *    status 				    print Hub availability
 *    list 				    list all registered clients
 *    access <appName>			    print <appName> availability
 *    handle <mtype>			    wait for <mtype> message
 *
 *    send <mtype> [<args> ...]		    generalized <mtype> message send
 *    exec <cmd>			    execute a client command
 *    pointAt <ra> <dec>		    point at given coords
 *    setenv  <name> <value>		    set an environment value
 *    getenv  <name>			    get an environment value
 *    setparam <name> <value>		    set a parameter value
 *    getparam <name>			    get a parameter value
 *
 *    load <url>			    load the named image/table file
 *    loadImage <url>			    load the named image
 *    loadVOTable <url>			    load the named VOTable
 *    loadFITS <url>			    load the named FITS bintable
 *    showRow [<tblId>] [<url>] <row>	    highlight specified row
 *    selectRows [<tblId>] [<url>] <rows>   select specified rows
 *    bibcode <bibcode>			    load the named bibcode
 *
 *
 *  @file       vosamp.c
 *  @author     Mike Fitzpatrick
 *  @date       6/03/12
 *
 *  @brief      Desktop SAMP messaging utility.
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <ctype.h>
#include <fcntl.h>
#include <time.h>

#include <netdb.h>
#include <sys/errno.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>


#include "samp.h"				/* LIBSAMP interface	    */
#include "voApps.h"				/* voApps interface	    */


#define	SZ_MTYPE	64
#define	SZ_BUF		128
#define	SZ_HOSTIP	16
#define	SZ_APPNAME	16
#define	SZ_BLOCK	4096

#define	ENV_PROXY	"VOSAMP_PROXY"


#define	MAX_ARGS	8
#define	VOS_TIMEOUT	600			/* 10-min proxy timeout     */
#define	VOS_DEFPORT	3999
#define	VOS_HUBWAIT	5

#define MATCH(s)        (strcasecmp(cmd,s)==0)


char    *to			= NULL;
char     senderIP[SZ_HOSTIP]; 
char     fname[SZ_FNAME]; 

static int	sampH		= 0;		/* samp struct handle	    */
						/* task options		    */
static int	verbose		= 0;		/* verbose output	    */
static int	debug		= 0;		/* verbose output	    */
static int	interact	= 0;		/* interactive shell	    */
static int	multiple	= 0;		/* accept multiple msgs	    */
static int 	xml_trace 	= 0;		/* trace XML_RPC	    */
static int 	keep_alive 	= 1;		/* lingering connection	    */
static int 	proxy_port	= VOS_DEFPORT;	/* proxy vosamp port	    */

static int	svr_sock	= 0;		/* child server socket	    */
static int	ipc_sock	= 0;		/* IPC sock (parent/child)  */
static int	session_sock	= 0;		/* session mgr socket       */
static int	use_ipc		= 0;		/* use IPC		    */
static int      have_dotfile 	= 0;		/* have a valid .vosamp?    */
static int	in_parent 	= 1;		/* are we parent process?   */
static int	do_return 	= 1;		/* return result to API     */
static int	timeout 	= VOS_TIMEOUT;	/* child timeout	    */

char  *session_host = "140.252.1.86";  		/* session manager host IP */
int    session_port = 4000;	         	/* session manager port    */
    
static char    *proxy		= NULL;		/* proxy connection string  */
static char    *session		= NULL;		/* session name		    */
static char    *pattern		= NULL;		/* SAMP msg pattern	    */
static char    *cmdfile		= NULL;		/* input command file	    */
static char    *filt_mtype      = NULL;		/* snoop filter mtype	    */
static char    *filt_sender     = NULL;		/* snoop sender name	    */
static char     cmd[SZ_CMD];			/* command name	    	    */
static char     cmdline[SZ_CMD];		/* full command line	    */
static char     proxy_host[SZ_FNAME];		/* proxy vosamp host name   */
static char     dotfile[SZ_FNAME];		/* path to local dotfile    */
static char    *args[MAX_ARGS];			/* command args buffer      */

static FILE   *fd		= (FILE *) NULL;
static fd_set allset, fds;
static struct timeval tm;


static int   vos_sampInit (void);
static void  vos_sampShutdown (void);
static void  vos_cmdHelp (char *cmd);
static void  vos_procCmd(int sampH, char *to, char *cmd, char **argv, int argc);
static void  vos_handleCmdInput (FILE *fd, char *args[], int numargs);
static void  vos_msgHandler (char *sender, char *msg_id, int params);
static void  vos_rewriteCmd (char *line, char *fname);
static char *vos_dotFile ();

int   vos_uploadFiles (int fd, char *cmdline);
int   vos_recvFile (int sock, int size, char *fname);
int   vos_sendFile (int sock, int size, char *fname);
int   vos_openSession (char *host, int port, char *session_name);
int   vos_closeSession (int sock);


extern void  vos_msgHandler (char *sender, char *msg_id, int params);
extern char *vos_toURL (char *arg);
extern char *vos_optArg (char *arg);
extern char *vos_getLocalIP (void);
extern int  *vos_toIntArray (char *arg, int *nrows);
extern void  vos_sessionHandler (char *sender, char *mtype, char *msg_id,
		Map map);


/*  Utility socket routines.
 */
extern int  vos_fileRead (int fd, void *vptr, int nbytes);
extern int  vos_fileWrite (int fd, void *vptr, int nbytes);
extern int  vos_openServerSocket (int port);
extern int  vos_openClientSocket (char *host, int port, int retry);
extern int  vos_sockRead (int fd, void *vptr, int nbytes);
extern int  vos_sockWrite (int fd, void *vptr, int nbytes);
extern int  vos_sockWriteHdr (int fd, int len, char *name, int type, 
				int mode, char *to);
extern int  vos_sockReadHdr (int fd, int *len, char *name, int *type, 
				int *mode);
extern void vos_setNonBlock (int sock);
extern struct hostent *vos_getHostByName (char *lhost);
extern struct hostent *vos_dupHostent (struct hostent *hentry);



/*  Task specific option declarations.
 */
int  vosamp (int argc, char **argv, size_t *len, void **result);

static Task  self       = {  "vosamp",  vosamp };
static char  *opts      = "%:hrdif:mps:t:vP:T:S:";
static struct option long_opts[] = {
        { "return",       0, 0,   'r'},         /* task option          */
        { "help",         0, 0,   'h'},         /* required             */
        { "test",         1, 0,   '%'},         /* required             */
        { "debug",        0, 0,   'd'},         /* debug		*/
        { "verbose",      0, 0,   'v'},         /* debug		*/
        { "manu",         0, 0,   'm'},         /* multiple msgs	*/
        { "sender",       1, 0,   's'},         /* sender filter	*/
        { "interactive",  0, 0,   'i'},         /* interactive mode	*/
        { "file",         1, 0,   'f'},         /* cmd file		*/
        { "pattern",      1, 0,   'p'},         /* msg pattern		*/
        { "proxy",        1, 0,   'P'},         /* proxy connection	*/
        { "session",      1, 0,   'S'},         /* session name		*/
        { "to",           1, 0,   't'},         /* recipient name	*/
        { "keepalive",    0, 0,   'k'},         /* keep connection 	*/
        { "timeout",      1, 0,   'T'},         /* connection timeout  	*/
        { NULL,           0, 0,    0 }
};

static void Usage (void);
static void Tests (char *input);



/****************************************************************************
 *  Program entry point.
 */
int
vosamp (int argc, char **argv, size_t *reslen, void **result)
{
    char **pargv, optval[SZ_FNAME], ch, *env_proxy = NULL;
    int	   i, pos = 0, numargs = 0; 
    time_t expiry;

session_host = "127.0.0.1";


    /*  Initialize.
     */
    memset (cmd, 0, SZ_CMD);				
    memset (cmdline, 0, SZ_CMD);				
    memset (proxy_host, 0, SZ_FNAME);				
    memset (dotfile, 0, SZ_FNAME);				

    strcpy (proxy_host, vos_getLocalIP ());
    strcpy (dotfile, vos_dotFile ());
    for (i=0; i < MAX_ARGS; i++) 
	args[i] = calloc (1, SZ_LINE);

    *reslen = 0;
    *result = NULL;


    /*  Parse the argument list.
     */
    pargv = vo_paramInit (argc, argv);
    i = 0;
    while ((ch = vo_paramNext (opts,long_opts,argc,pargv,optval,&pos)) != 0) {
	i++;
        if (ch > 0) {
            switch (ch) {
            case '%':  Tests (optval);                  return (OK);
            case 'h':  Usage ();                        return (OK);

            case 'd':  debug++;   			break;
            case 'v':  verbose++;			break;
            case 'k':  keep_alive=0;			break;
            case 'm':  multiple++;     			break;
            case 'i':  interact++;  			break;

            case 's':  filt_sender = strdup (optval);  	break;
            case 'f':  cmdfile     = strdup (optval);  	break;
            case 't':  to          = strdup (optval);	break;
            case 'p':  pattern     = strdup (optval);  	break;
            case 'P':  proxy       = strdup (optval);  	break;
            case 'S':  session     = strdup (optval);  	break;
            case 'T':  timeout 	   = atoi (optval);	break;

            case 'r':  do_return=1;                     break;	/*  NYI  */
            default:
                fprintf (stderr, "Invalid option '%s'\n", optval);
                return (1);
            }
        } else {
	    /*  Remainder of argv is the subcommand and its arguments.
	     */
	    if (pargv[i] == NULL)
		break;
	    if (!cmd[0]) {
                strcpy (cmd, optval);
	    } else {
		if (strcasecmp (cmd, "exec") == 0 || 
		    strcasecmp (cmd, "echo") == 0) {
		        strcat (args[0], optval);
		        strcat (args[0], " ");
		} else
                    strcpy (args[numargs++], pargv[i]);
	    }
        }
    }


    /*  Print command help if that's all we're asked.
     */
    if (strncmp (cmd, "?", 1) == 0 || strncasecmp (cmd, "help", 4) == 0) {
	Usage ();
	return (OK);
    }
    if (strncmp(args[0], "?", 1) == 0 || strncasecmp(args[0], "help", 4) == 0) {
	vos_cmdHelp (cmd);
	return (OK);
    }

    /*  Sanity checks.
     */
    if (interact)
	cmdfile = strdup ("-");
    if (to == NULL)
	to = strdup ("all");
    if (pattern == NULL)
	pattern = strdup ("async");


    /*  Initialize the SAMP interface.
    */
    tm.tv_sec  = timeout;
    tm.tv_usec = 0;
    session_sock = 0;


    /*  Check for environment definitions.
     */
    if ((env_proxy = getenv (ENV_PROXY)))
	proxy = strdup (env_proxy);

    if (proxy) {
	/*  We've been asked to send the command to a particular proxy, just
	 *  send the command line and any required data.
	 */
	char  *cp = strchr (proxy, (int)':');

	if (cp) {
	    proxy_port = atoi (cp+1);
	    *cp = '\0';
	    strcpy (proxy_host, proxy);
	} else {
	    proxy_port = VOS_DEFPORT;
	    strcpy (proxy_host, proxy);
	}
	use_ipc++;
	have_dotfile++;
	ipc_sock = vos_openClientSocket (proxy_host, proxy_port, 1);

    } else {
	/*  See if we have a local proxy running we can use instead of starting 
	 *  a new connection.  Data references remain local unless being
	 *  passed on to the session manager service.
	 */
	FILE  *fd = (FILE *) NULL;

	if (!interact && access (dotfile , R_OK) == 0) {
	    if ((fd = fopen (dotfile, "r+")) != (FILE *) NULL) {
		time_t  now = time ((time_t) 0);

		fscanf (fd, "%s  %d  %ld", proxy_host, &proxy_port, &expiry);
		fclose (fd);

		/*  Check for a stale dotfile. */
		if (now <= (expiry - 2)) {
		    use_ipc++;
		    have_dotfile++;
		    ipc_sock = vos_openClientSocket (proxy_host, proxy_port, 1);
		    if (ipc_sock < 0) {
		        if (verbose)
			    fprintf (stderr, "Removing broken dotfile ...\n");
		        unlink (dotfile);
            	        goto samp_init;
		    }
		} else {
		    if (verbose)
			fprintf (stderr, "Removing stale .vosamp file ...\n");
		    unlink (dotfile);
            	    goto samp_init;
		}
	    }
	} else {
	    /*  No remote command specified, no local connection, so connect to
	     *  the Hub as a new application.
	     */
samp_init:
            while (vos_sampInit () == 0) {
		/*  Wait for a Hub connection.
		 */
		if (debug || verbose) {
		    fprintf (stderr, "Waiting for Hub ....");
		    sleep (VOS_HUBWAIT);
		}	
	    }
	}
    }


    /*  Process the messages in the named file, or from the cmdline.  Since
     *  there is some overhead in connecting to the hub, this is an efficient
     *  way to send multiple messages from a single connection.
     */
    FD_ZERO (&allset);
    FD_SET (fileno(stdin), &allset);
    vos_setNonBlock (fileno(stdin));

    if (session) {
    	/*  Open a client connection to the VOSAMP Session Manager.
    	 */
    	if ((session_sock = vos_openSession (session_host, 
	     session_port, session)) < 0) {
       	         session_sock = -1;
	         session = NULL;
    	} else {
            FD_SET (session_sock, &allset);
            vos_setNonBlock (session_sock);
	}
    }

    if (cmdfile) {
	fd = (cmdfile[0] == '-' ? stdin : fopen (cmdfile, "r"));
	vos_handleCmdInput (fd, args, numargs);

    } else {
fprintf (stderr, "proc....use_ipc = %d\n", use_ipc);
	if (use_ipc) {
	    int  i, nread = 0, nwrite = 0, len = 0;

	    memset (cmdline, 0, SZ_CMD);
	    sprintf (cmdline, "%s %s ", cmd, args[0]);
	    for (i=1; i < numargs; i++) {
		strcat (cmdline, args[i]);
		strcat (cmdline, " ");
	    }
	    len = strlen (cmdline); cmdline[len-1] = '\0';

fprintf (stderr, "use_ipc  cmdine = '%s'\n", cmdline);
	    if (strcasecmp (proxy_host, vos_getLocalIP())) {
		int  nfiles = vos_uploadFiles (ipc_sock, cmdline);
		if (debug)
		    fprintf (stderr, "....sent %d data files....\n", nfiles);
	    }

	    /*  Send the command string.
	     */
	    vos_sockWriteHdr (ipc_sock, len, NULL, SAMP_CMD, SAMP_NOTIFY, to);
	    nwrite = vos_sockWrite (ipc_sock, cmdline, len);

	    /*  See if we have a result returned to us.  If so, it will be
	     *  a character string we should just print out.
	     */
	    nread = vos_sockRead (ipc_sock, &len, sizeof (int));
	    if (len > 0) {
		char *res = calloc (1, (len+1));	

	        nread = vos_sockRead (ipc_sock, res, len);
		printf ("%s\n", res);
		free ((void *) res);
	    }

	} else if (cmd[0]) {
fprintf (stderr, "processing cmd: '%s'\n", cmd);
	    vos_procCmd (sampH, to, cmd, args, numargs);
fprintf (stderr, "processing cmd: '%s' ....Done\n", cmd);
	}
    }


    /*  Start the keep-alive proxy server.
     */
    if (keep_alive && in_parent && !have_dotfile) {
	switch (fork()) {
	case 0:				/* start child proxy 	*/
	    /*  Open server socket, read future input from socket.
	     */
	    if ((svr_sock = vos_openServerSocket (proxy_port)) < 0) {
		fprintf (stderr, "Cannot open VOSAMP port %d\n", proxy_port);
		if (have_dotfile) unlink (dotfile);
	    }
	    /*  FIXME 
    	    FD_ZERO (&allset);
	    */ 
    	    FD_SET (svr_sock, &allset); vos_setNonBlock (svr_sock);

#ifdef CHILD_SESSION
	    if (session) {
    		/*  Open a client connection to the VOSAMP Session Manager.
    		 */
    		if ((session_sock = vos_openSession (session_host, 
		     session_port, session)) < 0) {
        	         session_sock = -1;
		         session = NULL;
    		} else {
    	            FD_SET (session_sock, &allset);
    	            vos_setNonBlock (session_sock);
		}
	    }
#endif

	    use_ipc++;
	    in_parent = 0;
	    vos_handleCmdInput (stdin, args, numargs);
	    break;
	case -1:			/* fork fails 			*/
	    if (verbose && in_parent)
	        fprintf (stderr, "%d  proxy fork failure.\n", (int)getpid());
	    break;
	default:			/* parent exits 		*/
	    sleep (2);			/* give child a chance to start */
	    break;
	}
    }


    /*  Close down and clean up.
     */
    if (!keep_alive)
        vos_sampShutdown ();

    if (to)          free ((void *) to);
    if (proxy)       free ((void *) proxy);
    if (cmdfile)     free ((void *) cmdfile);
    if (pattern)     free ((void *) pattern);
    if (session)     free ((void *) session);
    if (filt_sender) free ((void *) filt_sender);

    return (OK);
}


/**
 *  VOS_UPLOADFILES -- Upload any files on the commandline to the remote
 *  host.  The remote client is responsible for rewriting the commandline
 *  as appropriate, our job here is to suss out which are the file arguments.
 */
int
vos_uploadFiles (int sock, char *cmdline)
{
    char *ip, *op, buf[SZ_BUF], fname[SZ_FNAME];
    int   nfiles = 0;
    struct stat fs;


    for (ip=cmdline; *ip; ) {
	memset (buf, 0, SZ_BUF);
	memset (fname, 0, SZ_FNAME);
	for (op=buf; *ip && !isspace(*ip); )	/* get token		*/
	   *op++ = *ip++;

	/*  Upload the file.  If we have a file:// URL strip out the
	 *  local pathname.  Note that in this implementation we're 
	 *  limited to a single data file per-message.
	 */
	if (strncmp ("file://", buf, 7) == 0) {
	    strcpy (fname, &buf[7]);
	    if (access (fname, F_OK) < 0)	/* file doesn't exist	*/
	        return (-1);
	}
	if (access (buf, F_OK) == 0)
	    strcpy (fname, buf);

	if (fname[0]) {				/* upload the file	*/
	    if (debug) fprintf (stderr, "uploading file '%s'....\n", fname);
	    
    	    if (stat (fname, &fs) == 0) {
		if (vos_sendFile (sock, (int) fs.st_size, fname) != OK)
		    fprintf (stderr, "Error sending file '%s'\n", fname);
    	    }
	    nfiles++;
	}

	while (*ip && isspace (*ip))		/* skip whitespace	*/
	    ip++;
    }

    return (nfiles);
}


/**
 *  VOS_SENDFILE -- Send a file to a remote host.
 */
int
vos_sendFile (int sock, int size, char *fname)
{
    char  block[SZ_BLOCK], name[SZ_FNAME], *ip;
    int   fd, nread = 0, nleft = size, nb = 0;


    if ((fd = open (fname, O_RDONLY))) {
	/*  Strip any leading path information from the filename.  We need
  	 *  it to open the file, but care only about the image name on the
	 *  remote machine where the file can be put in a temp data directory
	 *  or on a web address.
	 */
	memset (name, 0, SZ_FNAME);
	if ((ip = strrchr (fname, (int)'/')))
	   strcpy (name, ip+1);
	else
	   strcpy (name, fname);

        /*  Send the header to pass the filename and size, then
         *  send the data itself.
         */
        vos_sockWriteHdr (sock, size, name, SAMP_DATA, 0, to);
        while (nleft > 0) {
	    memset (block, 0, SZ_BLOCK);
	    nb = min (SZ_BLOCK, nleft);

    	    /* Read from the file, write it to the socket.
     	     */
    	    vos_fileRead (fd, block, nb);
	    vos_sockWrite (sock, block, nb);

       	    nleft -= nb;
	    nread += nb;
        }
        close (fd);
    }

    return (OK);
}


/**
 *  VOS_RECVFILE -- Receive a file from a remote host.
 */
int
vos_recvFile (int sock, int size, char *fname)
{
    char  block[SZ_BLOCK];
    int   fd, nread = 0, nleft = size, nb = 0;


    /*  Read the file from the socket, write to the filename.
     */
    if (debug) fprintf (stderr, "receiving file '%s'....%d\n", fname, size);
    if ((fd = open (fname, O_WRONLY|O_CREAT, 0664))) {
        while (nleft > 0) {
            memset (block, 0, SZ_BLOCK);
	    nb = min (SZ_BLOCK, nleft);

	    /* Read from the socket, write it to the file.
	     */
            vos_sockRead (sock, block, nb);
	    vos_fileWrite (fd, block, nb);

            nleft -= nb;
            nread += nb;
        }
        close (fd);
    }

    return (OK);
}


/**
 *  VOS_HANDLECMDINPUT -- Handle input from an input source.
 */
static void
vos_handleCmdInput (FILE *fd, char *args[], int numargs)
{
    register int i, read_timeout = 0, rc;
    char  line[SZ_CMD];
    static char data_file[SZ_FNAME];


    memset (line, 0, SZ_CMD);
    memset (data_file, 0, SZ_FNAME);
    while (1) {		/* loop until timeout		*/

	/*  Write the interactive prompt to the screen.
	 */
        if ((interact || fd == stdin) && !use_ipc)
	    fprintf (stderr, "vosamp> ");

	/*  Initialize the input file descriptor set.
	 */
	fds = allset;
      	if ((rc = select (8, &fds, NULL, NULL, (timeout ? &tm : NULL))) == 0) {
	    read_timeout++;		/* input timeout	    */
	    unlink (dotfile); 		/* clean up the dotfile     */
       	    vos_sampShutdown ();	/* shutdown Hub connection  */
	    return;
	}

fprintf (stderr, "input ready on %d descriptors\n", rc);
	if (use_ipc && FD_ISSET(svr_sock, &fds)) {
	    int  nbytes = 0, nread = 0, type = 0, mode = 0;
	    char fname[SZ_FNAME];

       	    /* Accept a connection on the port.
       	     */
	    memset (line, 0, SZ_CMD);
	    memset (fname, 0, SZ_FNAME);
       	    if ((ipc_sock = accept (svr_sock, NULL, NULL)) < 0)
       		fprintf (stderr, "accept() errno %d: %s", 
		    errno, strerror(errno));

	    if (vos_sockReadHdr (ipc_sock, &nbytes, fname, &type, &mode)) {
	        if (strcasecmp (proxy_host, senderIP) && type == SAMP_DATA) {
		    if (vos_recvFile (ipc_sock, nbytes, fname) != OK) {
		        if (verbose || debug)
			    fprintf (stderr, "Error in recvFile '%s'\n", fname);
		    }
		    strcpy (data_file, fname);

	            if (vos_sockReadHdr(ipc_sock, &nbytes, fname,&type,&mode)) {
	                nread = vos_sockRead (ipc_sock, line, nbytes);
		        vos_rewriteCmd (line, data_file);
		    }
    		    memset (data_file, 0, SZ_FNAME);

	        } else if (type == SAMP_CMD) {
	            nread = vos_sockRead (ipc_sock, line, nbytes);
		    if (data_file[0]) {
		        vos_rewriteCmd (line, data_file);
    		        memset (data_file, 0, SZ_FNAME);
    		    }
	        } else if (type == SAMP_RESULT) {
		    ; /*  Not yet implemented  */
	        }
	    }

	} else if (session && FD_ISSET(session_sock, &fds)) {
	    int  nbytes = 0, nread = 0, type = 0, mode = 0;

	    fprintf (stderr, "got input on session socket....\n");
	    if (vos_sockReadHdr (session_sock, &nbytes, fname, &type, &mode))
	        nread = vos_sockRead (session_sock, line, nbytes);

	} else { 
	    if (fgets (line, SZ_CMD, fd) == NULL)
	        break;
	}

	/*  Kill trailing ws.
	 */
	if (isspace(line[strlen(line)-1]))
	    line[strlen(line)-1] = '\0';   

	memset (cmd, 0, SZ_CMD);
	for (i=0; i < MAX_ARGS; i++)
   	    memset (args[i], 0, SZ_LINE);

	if (strncasecmp (line, "exec", 4) == 0 ||
	    strncasecmp (line, "echo", 4) == 0) {
	        /*  Special-case for exec/echo cmd to create single arg
	         */
	        strncpy (cmd, line, 4);
	        sprintf (args[0], "%s", &line[5]);
	        numargs = 1;

	} else {
       	    numargs = sscanf (line, "%s %s %s %s %s %s %s %s %s", 
	        cmd, args[0], args[1], args[2], args[3], 
	           args[4], args[5], args[6], args[7]);
	}

	/*  Process the input command.
	 */
	vos_procCmd (sampH, to, cmd, args, numargs);

	if (use_ipc)
	    close (ipc_sock); 		/*  close the socket descriptor  */

        memset (line, 0, SZ_CMD);	/* clear the input buffer	 */
    }
    if (fd != stdin)
	fclose (fd);
}


/**
 *  VOS_REWRITECMD --  Rewrite the command string with filename substitution.
 */
static void
vos_rewriteCmd (char *line, char *fname)
{
    char *ip, *op, buf[SZ_CMD], obuf[SZ_CMD];

    memset (obuf, 0, SZ_CMD);
    for (ip=line; *ip; ) {
        memset (buf, 0, SZ_CMD);
        for (op=buf; *ip && !isspace(*ip); )    /* get token            */
           *op++ = *ip++;

        /*  Replace file-URI and absolute paths with the replacement filename.
         */
        if (strncmp ("file://", buf, 7) == 0 || buf[0] == '/')
            strcat (obuf, fname);
	else
            strcat (obuf, buf);

        while (*ip && isspace (*ip))            /* skip whitespace      */
            strncat (obuf, ip++, 1);
    }

    memset (line, 0, SZ_CMD);
    strcpy (line, obuf);
}


/**
 *  USAGE --  Print a task usage summary.
 */
static void
Usage (void)
{ 
 fprintf (stderr,
 "  Usage:\n"
 "\n" 
 "    %% vosamp [-hvd] [-t to] [-p pattern] [-f file] <cmd> [args ...]\n" 
 "\n" 
 "    where  <cmd>                  command to process\n" 
 "           -h                     print help summary\n" 
 "           -v                     verbose output\n" 
 "           -d                     debug output\n" 
 "\n" 
 "           -m                     handle multiple messages\n"
 "           -s <sender>            handly only msgs from <sender>\n"
 "\n" 
 "           -t <to>                send to specified app (or all)\n" 
 "           -p <pattern>           message pattern:  sync|async|notify\n" 
 "           -f <file>              send all commands in the file\n" 
 "\n" 
 "  Commands:\n" 
 "\n" 
 "  snoop                                 print all received messages\n"
 "  send <mtype> [<args> ...]             generalized <mtype> message send\n" 
 "\n" 
 "  status                                print Hub availability\n" 
 "  list                                  list all registered clients\n"
 "  access <appName>                      print <appName> availability\n" 
 "  handle <mtype>                        wait for <mtype> message\n" 
 "\n" 
 "  exec <cmd>                            execute a client command\n" 
 "  setenv  <name> <value>                set an environment value\n" 
 "  getenv  <name>                        get an environment value\n" 
 "  setparam <name> <value>               set a parameter value\n" 
 "  getparam <name>                       get a parameter value\n" 
 "\n" 
 "  load <url>                            load the image/table\n" 
 "  loadImage <url>                       load the named image\n" 
 "  loadVOTable <url>                     load the named VOTable\n" 
 "  loadFITS <url>                        load the named FITS bintable\n" 
 "  loadSpec <url>                        load the named spectrum\n" 
 "  loadResource <ivorn>                  load the named VO Resource\n" 
 "\n" 
 "  pointAt <ra> <dec>                    point at given coords\n" 
 "  showRow [<url>] [<tblId>] <row>       highlight specified row\n" 
 "  selectRows [<url>] [<tblId>] <rows>   select specified rows\n" 
 "  bibcode <bibcode>                     load the bibcode\n"
 "\n" 
 );
}



/**
 *  Tests -- Task unit tests.
 */
static void
Tests (char *input)
{
   vo_taskTest (self, "--help", NULL);
   vo_taskTest (self, input, NULL);
   vo_taskTest (self, "-n", input, NULL);
   vo_taskTest (self, "-o", "-", input, NULL);
}


/**
 *  VOS_DOTFILE -- Create a pathname to the .vosamp file indicating a 
 *  running local proxy server.
 */
static char *
vos_dotFile ()
{
    static char dotfile[SZ_FNAME];
    static int  initialized = 0;

    if (! initialized) {
        char   *home = NULL;

        if ((home = getenv ("HOME")) == NULL)
	    home = "./";
        memset (dotfile, 0, SZ_FNAME);
        sprintf (dotfile, "%s/.vosamp", home);
    }
    initialized++;

    return (dotfile);
}


/**
 *  VOS_SAMPINIT -- Initialize the SAMP/Proxy interface connection.
 */
static int
vos_sampInit (void)
{
    register int i = 0;
    FILE *df;


    /*  Initialize the SAMP interface.
    */
    sampH = sampInit ("vosamp", "VOClient SAMP Task");

    /*  Set alternative messaging pattern if requested. Valid values are
     *  'synch', 'asynch' or 'notify'.
     */
    if (pattern) {
	switch (tolower(pattern[0])) {
	case 's':  samp_setSyncMode (sampH);	break;	    /* default 	*/
	case 'a':  samp_setASyncMode (sampH);	break;
	case 'n':  samp_setNotifyMode (sampH);	break;
	default:
	    if (verbose)
		fprintf (stderr, "Warning: Invalid pattern '%s'\n", pattern);
	}
    } else {
        /*  Use Synchronous mode by default so we don't exit before receiving
         *  the reply.  Otherwise, we could cause an error in the recipient.
         */
        samp_setSyncMode (sampH);
    }

    /*  If we're not sending to a specific client, disable the name mapping
     *  to speed up the connection.
    if (strncmp (to, "all", 3) == 0)
	samp_setOpt (sampH, "mapClients", 0);
     */

    samp_Metadata (sampH, "author.name",   "Mike Fitzpatrick, NOAO");
    samp_Metadata (sampH, "author.email",  "fitz@noao.edu");
    samp_Metadata (sampH, "samp.icon.url",
        "http://iraf.noao.edu/images/iraf-icon.gif");
    samp_Metadata (sampH, "samp.description.html",
        "http://iraf.noao.edu/~fitz/voclient/vosamp.html");
    samp_Metadata (sampH, "samp.icon.url", 
	"http://iraf.noao.edu/~fitz/voclient/vao_icon.gif");

    /*  If we're in session mode, subscribe to all message types.  The
     *  same handler is used to pass on the message to other clients in
     *  the session.
     */
    if (session) {
	static char *mtypes[] = {
          "samp.app.ping",   	"samp.app.event.*", 	"samp.hub.event.*",
          "image.load.fits", 	"table.highlight.row", 	"table.load.fits",
          "table.load.votable", "table.select.rowList", "client.cmd.exec",
          "client.param.set", 	"client.param.get", 	"client.env.set",
          "client.env.get", 	"voresource.loadlist", 	"coord.pointAt.sky",
	  "bibcode.load", 	"spectrum.load.*", 
	  NULL
	};

	for (i=0; mtypes[i]; i++)
            samp_Subscribe (sampH, mtypes[i],  vos_sessionHandler);

    } else {
	static char *mtypes[] = {
          "samp.app.ping",   	"samp.app.event.*", 	"samp.hub.event.*",
          "client.cmd.exec", 	"client.param.set", 	"client.param.get",
	  "client.env.set", 	"client.env.get", 	NULL
	};

	for (i=0; mtypes[i]; i++)
            samp_Subscribe (sampH, mtypes[i],  vos_sessionHandler);
    }


    /*  Register with the Hub and begin messaging.
     */
    sampStartup (sampH);


    /*  Write the dotfile.
     */
    if (!interact && (df = fopen (vos_dotFile(), "w+")) != (FILE *) NULL) {
	fprintf (df, "%s  %d  %ld\n", vos_getLocalIP(), proxy_port,
	    (long) (time((time_t)0) + timeout));
	fclose (df);
    }

    return (sampH);
}


/**
 *  VOS_SAMPSHUTDOWN -- Shutdown the SAMP/Proxy interface connection.
 */
static void
vos_sampShutdown (void)
{
    if (sampShutdown (sampH) < 0) 			/*  clean up 	*/
	fprintf (stderr, "SAMP shutdown fails\n");
    sampClose (sampH);
}


/**
 *  VOS_MSGHANDLER -- Incoming message handler.
 */
static void
vos_msgHandler (char *sender, char *msg_id, int params)
{
fprintf (stderr, "in vos_msgHandler.....\n");
    if (filt_sender && strcasecmp (filt_sender, sender))
        return;

    /*  Either no filters were set, or the message is of the requested type,
     *  print the contents.
     */
    samp_printMessage (filt_mtype, samp_id2app (sampH, sender), msg_id, params);

    if (!interact && !multiple) {       /*  Do a clean disconnect ....  */
        if (sampShutdown (sampH) < 0)
            fprintf (stderr, "SAMP shutdown fails\n");
        sampClose (sampH);
        exit (0);
    }
}


/**
 *  VOS_PROCCMD -- Process the command and its arguments.
 */
static void
vos_procCmd (int sampH, char *to, char *cmd, char *args[], int numargs)
{
    int   i, reslen = 0, stat = OK;
    char *result = NULL;
    char buf[SZ_BUF];



    /*  Print command help.
     */
    if (strncmp (cmd, "?", 1) == 0) {
	Usage ();
	return;
    }
    if (strncmp (args[0], "?", 1) == 0) {
	vos_cmdHelp (cmd);
	return;
    }


    /********************************************
     ***         VOSAMP Custom Commands        **
     ********************************************/
    if (MATCH ("status")) {
	stat = (sampH >= 0);

    } else if (MATCH ("handle")) {
	int timeout = (atoi (args[1]) == 0 ? 999999 : atoi (args[1]));

	if (verbose)
	    fprintf (stderr, "Waiting for '%s' ....\n", args[0]);
	if (*args[1])
	    filt_sender = args[1];

	samp_Subscribe (sampH, (filt_mtype = args[0]), vos_msgHandler);
    	samp_DeclareSubscriptions (sampH);
	sleep (timeout);

    } else if (MATCH ("snoop")) {
        /*  Subscribe to all message types and install the snoop handler.
         *  Sleep forever so the handler can print anything it receives.
         */
	multiple = 1;
        samp_Subscribe (sampH, "*",  vos_msgHandler);
    	samp_DeclareSubscriptions (sampH);
	sleep (9999999);

    } else if (MATCH ("send")) {
	if (strcasecmp (to, "all"))	/* no recipient, use broadcast */
	    samp_setASyncMode (sampH);
        stat = samp_sendGeneric (sampH, to, args[0], &args[1]);

    } else if (MATCH ("echo")) {     			/* ECHO 	      */
	for (i=0; i < numargs; i++)
	    printf ("%s ", args[i]);
	printf ("\n");


    } else if (MATCH ("start")) {     			/* START 	      */
	if (!use_ipc)
            printf ("Starting SAMP interface .....\n");
        sampStartup (sampH);

    } else if (MATCH ("stop")) {      			/* STOP 	      */
        if (!use_ipc)
	    printf ("Stopping SAMP interface .....\n");
        sampShutdown (sampH);

    } else if (MATCH ("help")) {      			/* HELP 	      */
        Usage ();

    } else if (MATCH ("quit")) {                   	/* QUIT 	      */
        if (sampShutdown (sampH) < 0) {
	    if (!use_ipc)
                fprintf (stderr, "Shutdown fails\n");
	}
        sampClose (sampH);
	unlink (vos_dotFile());
        exit (0);

    } else if (MATCH ("trace")) {          		/* TRACE 	      */
        xml_trace++;
        if (xml_trace % 2)
            setenv ("XMLRPC_TRACE_XML", "1", 1);
        else
            unsetenv ("XMLRPC_TRACE_XML");

    } else if (MATCH ("listClients")) {         	/* LIST CLIENTS	      */
	char *clist = NULL;

	samp_mapClients (sampH);
        clist = samp_getClients (sampH);
	if (use_ipc) {
	    reslen = strlen (clist);
	    result = strdup (clist);
	} else
	    printf ("Clients:\n%s", clist);
	


    /********************************************
     ***      Hub Administrative Messages     ***
     ********************************************/
    } else if (MATCH ("ping")) {		/* samp.app.ping 	      */
        stat = samp_Ping (sampH, "Hub");



    /********************************************
     ***    Client Administrative Messages    ***
     ********************************************/
    } else if (MATCH ("ping")) {		/* samp.app.ping 	      */
        stat = samp_Ping (sampH, to);

    } else if (MATCH ("access")) {		/* samp.app.ping 	      */
        stat = samp_Ping (sampH, to);



    /********************************************
     ***    Table/Image Load Message Types    ***
     ********************************************/
						/* image.load.fits 	      */
    } else if (MATCH ("loadImage") || MATCH ("loadFITS")) {
        stat = samp_imageLoadFITS (sampH, to, 
		vos_toURL (args[0]),		/* URL/file 	*/
		vos_optArg (args[1]), 		/* imgId	*/
		vos_optArg (args[2]));		/* name		*/

    } else if (MATCH ("loadVOTable")) {		/* table.load.votable 	      */
        stat = samp_tableLoadVOTable (sampH, to, 
		vos_toURL (args[0]), 		/* URL/file 	*/
		vos_optArg (args[1]), 		/* tblId	*/
		vos_optArg (args[2]));		/* name		*/

    } else if (MATCH ("load")) {
	extern int vot_fileType();

	if (access (args[0], F_OK) == 0) {
	    switch (vot_fileType (args[0])) {
	    case VOT_FITS:
                stat = samp_imageLoadFITS (sampH, to, 
		    vos_toURL (args[0]),	/* URL/file 	*/
		    vos_optArg (args[1]), 	/* imgId	*/
		    vos_optArg (args[2]));	/* name		*/
	        break;
	    case VOT_VOTABLE:
                stat = samp_tableLoadVOTable (sampH, to, 
		    vos_toURL (args[0]), 	/* URL/file 	*/
		    vos_optArg (args[1]), 	/* tblId	*/
		    vos_optArg (args[2]));	/* name		*/
	        break;
	    case VOT_FITS_SPEC:
	        break;
	    case VOT_VOTABLE_SPEC:
	        break;
	    default:
	        if (!use_ipc)
	            fprintf (stderr,
			"Error: cannot determine file type of '%s'.\n",
		        args[0]);
	    }
	} else
	    fprintf (stderr, "Error: cannot access '%s'.\n", args[0]);



    /********************************************
     ***        Resource Message Types        ***
     ********************************************/
    } else if (MATCH ("loadResource")) {	/* voresource.loadlist        */
	/*  NYI  */



    /********************************************
     ***         Utility Message Types        ***
     ********************************************/
    } else if (MATCH ("showRow")) {		/* table.highlight.row        */
		/* showRow <url> <row> [<id>]	*/
        stat = samp_tableHighlightRow (sampH, to, 
		vos_optArg (args[2]),		/* table-id 	*/
		vos_toURL (args[0]),		/* URL/file 	*/
		atoi(args[1]));			/* row 		*/
	
    } else if (MATCH ("selectRows")) {		/* table.select.rowList       */
	int  nrows = 0;
	int *rows = vos_toIntArray (args[2], &nrows);

	stat = samp_tableSelectRowList (sampH, to, 
		vos_optArg (args[0]),		/* table-id	*/
                vos_toURL (args[1]),		/* URL/file	*/
		rows,				/* rows[]	*/
		nrows);				/* row 		*/

    } else if (MATCH ("pointAt")) {		/* coord.pointAt.sky          */
        stat = samp_coordPointAtSky (sampH, to, 
		atof(args[0]), 			/* RA		*/
		atof(args[1]));			/* Dec		*/


    /********************************************
     ***     Spectrum Load Message Types      ***
     ********************************************/
    } else if (MATCH ("loadSpec")) {		/* spectrum.load.ssa-generic  */
	/*  FIXME -- meta map not implemented */
	stat = samp_specLoadSSAGeneric (sampH, to, 
		vos_toURL (args[0]),		/* URL		*/
		0, 				/* Map meta	*/  /* NYI */
		vos_optArg (args[2]), 		/* spectrumId	*/
		vos_optArg (args[3]));		/* name		*/


    /********************************************
     ***         Bibcode Message Types        ***
     ********************************************/
    } else if (MATCH ("bibcode")) {		/* bibcode.load	              */
        stat = samp_bibLoad (sampH, to, args[1]);


    /********************************************
     ***         VO/IRAF Message Types        ***
     ********************************************/
    } else if (MATCH ("exec")) {		/* client.cmd.exec    	      */
        samp_cmdExec (sampH, to, args[0]);

    } else if (MATCH ("getenv")) {		/* client.env.get     	      */
        char *v = samp_envGet (sampH, to, 
		args[0]); 			/* name		*/
	if (use_ipc) {
	    reslen = strlen (v);
	    result = strdup (v);
	} else
	    printf ("%s\n", v);
  	free ((void *) v);

    } else if (MATCH ("setenv")) {		/* client.env.set     	      */
        stat = samp_envSet (sampH, to, 
		args[0], 			/* name		*/
		args[1]);			/* value	*/

    } else if (MATCH ("getparam")) {		/* client.param.get   	      */
        char *v = samp_paramGet (sampH, to, 
		args[0]); 			/* name		*/
	if (use_ipc) {
	    reslen = strlen (v);
	    result = strdup (v);
	} else
	    printf ("%s\n", v);
  	free ((void *) v);

    } else if (MATCH ("setparam")) {		/* client.param.set           */
        stat = samp_paramSet (sampH, to, 
		args[0], 			/* name		*/
		args[1]);			/* value	*/


    /********************************************
     ***            Unknown Command           ***
     ********************************************/
    } else {
	if (use_ipc) {
	    memset (buf, 0, SZ_BUF);
	    sprintf (buf, "Error: unknown command '%s'\n", cmd);
	    result = strdup (buf);
	    reslen = strlen (buf);
	} else
	    fprintf (stderr, "Error: unknown command '%s'\n", cmd);
    }


    if (verbose) {
        if (use_ipc) {
	    result = strdup ((stat < 0 ? "Error" : "OK"));
	    reslen = strlen (result);
        } else
            fprintf (stderr, "%s\n", (stat < 0 ? "Error" : "OK"));
    }
    if (debug)
	fprintf (stderr, "procCmd: reslen=%d  result='%s'\n", reslen, result);
	

    /*  Return result to the remote caller.
     */
    if (use_ipc) {
	vos_sockWrite (ipc_sock, &reslen, sizeof(int));
        if (reslen) {
	    vos_sockWrite (ipc_sock, result, reslen);
	    free (result);
	}
    }
}


/**
 *  VOS_CMDHELP -- Print a command help summary for interactive mode.
 */
static void
vos_cmdHelp (char *cmd)
{
    if (MATCH ("status")) {
	printf ("status\n");
    } else if (MATCH ("handle")) {
	;
    } else if (MATCH ("snoop")) {
	printf ("snoop\n");
    } else if (MATCH ("send")) {
	;
    } else if (MATCH ("start")) {
	printf ("start\n");
    } else if (MATCH ("stop")) {
	printf ("stop\n");
    } else if (MATCH ("echo")) {
	printf ("echo <text_string>\n");
    } else if (MATCH ("help")) {
	printf ("help <cmd>\n");
    } else if (MATCH ("quit")) {
	printf ("quit\n");
    } else if (MATCH ("trace")) {
	printf ("trace\n");
    } else if (MATCH ("listClients")) {
	printf ("listClients\n");
    } else if (MATCH ("ping")) {
	printf ("ping <appName>\n");
    } else if (MATCH ("access")) {
	printf ("access <appName>\n");

    } else if (MATCH ("loadImage") || MATCH ("loadFITS")) {
	printf ("loadImage <file | URL> [<table-id> [<name>]]\n");
    } else if (MATCH ("loadVOTable")) {
	printf ("loadVOTable <file | URL> [<table-id> [<name>]]\n");
    } else if (MATCH ("loadResource")) {
	;
    } else if (MATCH ("showRow")) {
	printf ("showRow <table-id> <file | URL> <row>\n");
    } else if (MATCH ("selectRows")) {
	printf ("selectRows <table-id> <file | URL> <rowList>\n");

    } else if (MATCH ("pointAt")) {
	printf ("pointAt <ra> <dec>\t# coords in decimal degrees\n");

    } else if (MATCH ("loadSpec")) {
	printf ("loadSpec <URL> <meta> [<spectrum-id> <name>]\n");
    } else if (MATCH ("bibcode")) {
	printf ("bibcode <bibcode>\n");

    } else if (MATCH ("exec")) {
	printf ("exec <cmd_str>\n");
    } else if (MATCH ("getenv")) {
	printf ("getenv <name>\n");
    } else if (MATCH ("setenv")) {
	printf ("setenv <name> <value>\n");
    } else if (MATCH ("getparam")) {
	printf ("getparam <name>\n");
    } else if (MATCH ("setparam")) {
	printf ("setparam <name> <value>\n");
    }
}



/**
 *  VOS_OPENSESSION -- Open a connection to the VOSAMP Session Manager.
 *
 *  @brief      Open a connection to the VOSAMP Session Manager.
 *  @fn         int vos_openSession (char *host, int port, char *session_name)
 *
 *  @param  host        session manager host
 *  @param  port        session manager connection port
 *  @param  name        session name
 *  @return             fd to the session socket
 */
int
vos_openSession (char *host, int port, char *session_name)
{
    int   sock = 0, cb_sock = 0, cb_port = 0, nr, nw, len, ready = SESS_READY;
    char  cmd[SZ_LINE];


    /*  Open a socket to the connection port.
     */
    if ((sock = vos_openClientSocket (host, port, 1)) <= 0)
	return (1);

    /*  Read the callback port number.
     */
    if ((nr = vos_sockRead (sock, &cb_port, sizeof (int))) != sizeof (int))
	return (1);

    /*  Close the socket to the connection port.
     */
    close (sock); 		

    /*  Open a new connection to the callback port.
     */
    if ((cb_sock = vos_openClientSocket (host, cb_port, 1)) <= 0)
	return (1);

    /*  Write the 'ready' code to the callback prot.
     */
    nw = vos_sockWrite (cb_sock, &ready, sizeof (int));


    /*  Send the 'connect' message to connect to the named session.  The
     *  server will either create a new session or have us join an existing
     *  session created by another node.
     */
    memset (cmd, 0, SZ_LINE);
    sprintf (cmd, "connect %s", session_name);
    len = strlen (cmd);
    vos_sockWriteHdr (cb_sock, len, NULL, SAMP_CMD, SAMP_NOTIFY, "smgr");
    nw = vos_sockWrite (cb_sock, cmd, len);

    /*  Return 0 if we can connect, 1 on err, or the callback descriptor.
     */
    return (cb_sock);
}


/**
 *  VOS_CLOSESESSION -- Close the specified session connection.
 *
 *  @brief      Close the specified session connection.
 *  @fn         int vos_closeSession (int sock)
 *
 *  @param  sock        session socket fd
 *  @return             0 if cmd was sent, 1 otherwise
 */
int
vos_closeSession (int sock)
{
    if (vos_sockWriteHdr (sock, 0, NULL, SAMP_QUIT, SAMP_NOTIFY, "smgr"))
	return (1);
    return (0);
}

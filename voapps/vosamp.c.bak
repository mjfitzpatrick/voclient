/**
 *  VOSAMP - Example task to send a single SAMP message for the cmdline.
 *
 *  Usage:
 *
 *	vosamp [<opts>] <cmd> [args ...]
 *
 *  Where	
 *	<cmd>				command to process
 *  	-%,--test			run unit tests
 *  	-h,--help			print help summary
 *  	-d,--debug			debug output
 *  	-v,--verbose			verbose output
 *
 *  	-i,--interact			interactive mode
 *  	-m,--many			handle multiple messages
 *  	-s,--sender <sender>		handle only messages from <sender>
 *
 *  	-t,--to <to>			send to specified application (or all)
 *  	-p,--pattern <pattern>		message pattern:  sync|async|notify
 *  	-f,--file <file>		send all commands in the file
 *  	-k,--keepalive			disable keep_alive feature
 *
 *  	-P,--proxy <pattern>		message pattern:  sync|async|notify
 *  	-T,--timeout <N>		keepalive timeout
 *  	-S,--session <name>		session name
 *
 *	-r,--return			return result to API
 *
 *
 *  Subcommands:
 *
 *    snoop 				    print all received messages
 *
 *    status 				    print Hub availability
 *    list 				    list all registered clients
 *    access <appName>			    print <appName> availability
 *    handle <mtype>			    wait for <mtype> message
 *
 *    send <mtype> [<args> ...]		    generalized <mtype> message send
 *    exec <cmd>			    execute a client command
 *    pointAt <ra> <dec>		    point at given coords
 *    setenv  <name> <value>		    set an environment value
 *    getenv  <name>			    get an environment value
 *    setparam <name> <value>		    set a parameter value
 *    getparam <name>			    get a parameter value
 *
 *    load <url>			    load the named image/table file
 *    loadImage <url>			    load the named image
 *    loadVOTable <url>			    load the named VOTable
 *    loadFITS <url>			    load the named FITS bintable
 *    showRow [<tblId>] [<url>] <row>	    highlight specified row
 *    selectRows [<tblId>] [<url>] <rows>   select specified rows
 *    bibcode <bibcode>			    load the named bibcode
 *
 *
 *  @file       vosamp.c
 *  @author     Mike Fitzpatrick
 *  @date       6/03/12
 *
 *  @brief      Desktop SAMP messaging utility.
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <ctype.h>
#include <fcntl.h>
#include <time.h>

#include <netdb.h>
#include <sys/errno.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>


#include "samp.h"				/* LIBSAMP interface	    */
#include "voApps.h"				/* voApps interface	    */


#define	SZ_MTYPE	64
#define	SZ_BUF		128
#define	SZ_HOSTIP	16
#define	SZ_APPNAME	16

#define	MAX_ARGS	8
#define	VOS_TIMEOUT	600			/* 10-min timeout	    */
#define	VOS_DEFPORT	4000

#define MATCH(s)        (strcasecmp(cmd,s)==0)


#define	SAMP_CMD	0			/* message is a command	    */
#define	SAMP_DATA	1			/* message is data file	    */
#define	SAMP_RESULT	2			/* message is cmd result    */

typedef struct {
    int   nbytes;				/* length of msg body	    */
    int   mode;					/* sync, async, notify	    */
    int   type;					/* SAMP cmd, data, result   */
    char  session[SZ_APPNAME];			/* session name	    	    */
    int   sessionPort;				/* session port number	    */
    char  recipient[SZ_APPNAME];		/* recipient app name	    */
    char  senderIP[SZ_HOSTIP];			/* sender's IP address	    */
    int   senderPort;				/* sender's port	    */

    int   verbose;				/* verbose flag 	    */
    int   debug;				/* debug flag 		    */
} cmdHdr, *cmdHdrP;

cmdHdr  msgHdr;


static int	sampH		= 0;		/* samp struct handle	    */

static int	verbose		= 0;		/* task options		    */
static int	debug		= 0;
static int	multiple	= 0;
static int	interact	= 0;
static int 	xml_trace 	= 0;
static int 	keep_alive 	= 1;
static int 	port 		= VOS_DEFPORT;

static int	svr_sock	= 0;		/* child server socket	    */
static int	ipc_sock	= 0;		/* IPC sock (parent/child)  */
static int	session_sock	= 0;		/* session mgr socket       */
static int	use_ipc		= 0;		/* use IPC		    */
static int      have_dotfile 	= 0;		/* have a valid .vosamp?    */
static int	in_parent 	= 1;		/* are we parent process?   */
static int	do_return 	= 1;		/* return result to API     */
static int	timeout 	= VOS_TIMEOUT;	/* child timeout	    */
    
static char    *to		= NULL;
static char    *proxy		= NULL;
static char    *session		= NULL;
static char    *pattern		= NULL;
static char    *cmdfile		= NULL;
static char    *filt_mtype      = NULL;
static char    *filt_sender     = NULL;
static char     cmd[SZ_CMD];
static char     host[SZ_FNAME];
static char     dotfile[SZ_FNAME];
static char     senderIP[SZ_HOSTIP];
static char    *args[MAX_ARGS];

static FILE   *fd		= (FILE *) NULL;
static fd_set allset, fds;
static struct timeval tm;


static void  vos_sampInit (void);
static void  vos_sampShutdown (void);
static void  vos_cmdHelp (char *cmd);
static void  vos_msgHandler (char *sender, char *msg_id, int params);
static void  vos_procCmd(int sampH, char *to, char *cmd, char **argv, int argc);
static void  vos_handleCmdInput (FILE *fd, char *args[], int numargs);
static char *vos_toURL (char *arg);
static char *vos_optArg (char *arg);
static char *vos_getLocalIP (void);
static char *vos_dotFile ();
static int  *vos_toIntArray (char *arg, int *nrows);
static int   vos_sessionHandler (char *sender, char *mtype, char *msg_id,
		Map map);

/*  Private socket routines.
 */
static int  vos_openServerSocket (int port);
static int  vos_openClientSocket (char *host, int port, int retry);
static int  vos_sockRead (int fd, void *vptr, int nbytes);
static int  vos_sockWrite (int fd, void *vptr, int nbytes);
static void vos_setNonBlock (int sock);
static void vos_sockWriteHdr (int fd, int len, int type, int mode, char *to);
static void vos_sockReadHdr (int fd, int *len, int *type, int *mode);
static struct hostent *vos_getHostByName (char *lhost);
static struct hostent *vos_dupHostent (struct hostent *hentry);



/*  Task specific option declarations.
 */
int  vosamp (int argc, char **argv, size_t *len, void **result);

static Task  self       = {  "vosamp",  vosamp };
static char  *opts      = "%:hrdif:mps:t:vP:T:S:";
static struct option long_opts[] = {
        { "return",       0, 0,   'r'},         /* task option          */
        { "help",         0, 0,   'h'},         /* required             */
        { "test",         1, 0,   '%'},         /* required             */
        { "debug",        0, 0,   'd'},         /* debug		*/
        { "verbose",      0, 0,   'v'},         /* debug		*/
        { "manu",         0, 0,   'm'},         /* multiple msgs	*/
        { "sender",       1, 0,   's'},         /* sender filter	*/
        { "interactive",  0, 0,   'i'},         /* interactive mode	*/
        { "file",         1, 0,   'f'},         /* cmd file		*/
        { "pattern",      1, 0,   'p'},         /* msg pattern		*/
        { "proxy",        1, 0,   'P'},         /* proxy connection	*/
        { "session",      1, 0,   'S'},         /* session name		*/
        { "to",           1, 0,   't'},         /* recipient name	*/
        { "keepalive",    0, 0,   'k'},         /* keep connection 	*/
        { "timeout",      1, 0,   'T'},         /* connection timeout  	*/
        { NULL,           0, 0,    0 }
};

static void Usage (void);
static void Tests (char *input);



/****************************************************************************
 *  Program entry point.
 */
int
vosamp (int argc, char **argv, size_t *reslen, void **result)
{
    char **pargv, optval[SZ_FNAME], ch;
    char   line[SZ_CMD];
    int	   i, pos = 0, numargs = 0; 
    time_t expiry;


    /*  Initialize.
     */
    memset (cmd, 0, SZ_CMD);				
    memset (host, 0, SZ_FNAME);				
    memset (dotfile, 0, SZ_FNAME);				

    strcpy (host, vos_getLocalIP ());
    strcpy (dotfile, vos_dotFile ());
    for (i=0; i < MAX_ARGS; i++) 
	args[i] = calloc (1, SZ_LINE);

    *reslen = 0;
    *result = NULL;


    /*  Parse the argument list.
     */
    pargv = vo_paramInit (argc, argv);
    while ((ch = vo_paramNext (opts,long_opts,argc,pargv,optval,&pos)) != 0) {
        if (ch > 0) {
            switch (ch) {
            case '%':  Tests (optval);                  return (OK);
            case 'h':  Usage ();                        return (OK);

            case 'd':  debug++;   			break;
            case 'v':  verbose++;			break;
            case 'k':  keep_alive=0;			break;
            case 'm':  multiple++;     			break;
            case 'i':  interact++;  			break;

            case 's':  filt_sender = strdup (optval);  	break;
            case 'f':  cmdfile     = strdup (optval);  	break;
            case 't':  to          = strdup (optval);	break;
            case 'p':  pattern     = strdup (optval);  	break;
            case 'P':  proxy       = strdup (optval);  	break;
            case 'S':  session     = strdup (optval);  	break;
            case 'T':  timeout 	   = atoi (optval);	break;

            case 'r':  do_return=1;                     break;	/*  NYI  */
            default:
                fprintf (stderr, "Invalid option '%s'\n", optval);
                return (1);
            }
        } else {
	    /*  Remainder of argv is the subcommand and its arguments.
	     */
	    if (!cmd[0]) {
                strcpy (cmd, optval);
	    } else {
		if (strcasecmp (cmd, "exec") == 0 || 
		    strcasecmp (cmd, "echo") == 0) {
		        strcat (args[0], optval);
		        strcat (args[0], " ");
		} else
                    strcpy (args[numargs++], optval);
	    }
        }
    }


    /*  Print command help if that's all we're asked.
     */
    if (strncmp (cmd, "?", 1) == 0 || strncasecmp (cmd, "help", 4) == 0) {
	Usage ();
	return (OK);
    }
    if (strncmp(args[0], "?", 1) == 0 || strncasecmp(args[0], "help", 4) == 0) {
	vos_cmdHelp (cmd);
	return (OK);
    }

    /*  Sanity checks.
     */
    if (interact)
	cmdfile = strdup ("-");
    if (to == NULL)
	to = strdup ("all");


    /*  Initialize the SAMP interface.
    */
    tm.tv_sec  = timeout;
    tm.tv_usec = 0;
    session_sock = 0;


    if (proxy) {
	/*  We've been asked to send the command to a particular proxy, just
	 *  send the command line and any required data.
	 */
	char  *cp = strchr (proxy, (int)':');

	if (cp) {
	    port = atoi (cp+1);
	    *cp = '\0';
	    strcpy (host, proxy);
	} else {
	    port = VOS_DEFPORT;
	    strcpy (host, proxy);
	}
	use_ipc++;
	have_dotfile++;
	ipc_sock = vos_openClientSocket (host, port, 1);

    } else {
	/*  See have a local proxy running we can use instead of starting 
	 *  a new connection.  Data references remain local.
	 */
	FILE  *fd = (FILE *) NULL;

	if (!interact && access (dotfile , R_OK) == 0) {
	    if ((fd = fopen (dotfile, "r+")) != (FILE *) NULL) {
		time_t  now = time ((time_t) 0);

		fscanf (fd, "%s  %d  %ld", host, &port, &expiry);
		fclose (fd);

		/*  Check for a stale dotfile. */
		if (now <= (expiry - 2)) {
		    use_ipc++;
		    have_dotfile++;
		    ipc_sock = vos_openClientSocket (host, port, 1);
		} else {
		    if (verbose)
			fprintf (stderr, "Removing stale .vosamp file ...\n");
		    unlink (dotfile);
            	    vos_sampInit ();
		}
	    }
	} else {
	    /*  No remote command specified, no local connection, so connect to
	     *  the Hub as a new application.
	     */
            vos_sampInit ();
	}
    }


    /*  Process the messages in the named file, or from the cmdline.  Since
     *  there is some overhead in connecting to the hub, this is an efficient
     *  way to send multiple messages from a single connection.
     */
    FD_ZERO (&allset);
    FD_SET (fileno(stdin), &allset);
    vos_setNonBlock (fileno(stdin));

    if (cmdfile) {
	fd = (cmdfile[0] == '-' ? stdin : fopen (cmdfile, "r"));
	vos_handleCmdInput (fd, args, numargs);

    } else {
	if (use_ipc) {
	    int  i, nread = 0, nwrite = 0, len = 0;

	    memset (line, 0, SZ_CMD);
	    sprintf (line, "%s %s ", cmd, args[0]);
	    for (i=1; i < numargs; i++) {
		strcat (line, args[i]);
		strcat (line, " ");
	    }
	    len = strlen (line);

	    vos_sockWriteHdr (ipc_sock, len, SAMP_CMD, SAMP_NOTIFY, to);
	    nwrite = vos_sockWrite (ipc_sock, line, len);

	    /*  See if we have a result returned to us.  If so, it will be
	     *  a character string we should just print out.
	     */
	    nread = vos_sockRead (ipc_sock, &len, sizeof (int));
	    if (len > 0) {
		char *res = calloc (1, (len+1));	

	        nread = vos_sockRead (ipc_sock, res, len);
		printf ("%s\n", res);
		free ((void *) res);
	    }

	} else
	    vos_procCmd (sampH, to, cmd, args, numargs);
    }


    /*  Start the keep-alive proxy server.
     */
    if (keep_alive && in_parent && !have_dotfile) {
	switch (fork()) {
	case 0:			/* start child proxy 	*/
	    /*  Open server socket, read future input from socket.
	     */
	    if ((svr_sock = vos_openServerSocket (port)) < 0)
		fprintf (stderr, "Cannot open server port %d\n", port);
    	    FD_ZERO (&allset);
    	    FD_SET (svr_sock, &allset);
    	    vos_setNonBlock (svr_sock);
	    use_ipc++;
	    in_parent = 0;
	    vos_handleCmdInput (stdin, args, numargs);
	    break;
	case -1:			/* fork fails 			*/
	    if (verbose && in_parent)
	        fprintf (stderr, "%d  proxy fork failure.\n", (int)getpid());
	    break;
	default:			/* parent exits 		*/
	    sleep (2);			/* give child a chance to start */
	    break;
	}
    }


    /*  Close down and clean up.
     */
    if (!keep_alive)
        vos_sampShutdown ();

    if (to)          free ((void *) to);
    if (proxy)       free ((void *) proxy);
    if (cmdfile)     free ((void *) cmdfile);
    if (pattern)     free ((void *) pattern);
    if (session)     free ((void *) session);
    if (filt_sender) free ((void *) filt_sender);

    return (OK);
}


/**
 *  VOS_HANDLECMDINPUT -- Handle input from an input source.
 */
static void
vos_handleCmdInput (FILE *fd, char *args[], int numargs)
{
    register int i, read_timeout = 0;
    char  line[SZ_CMD];


    memset (line, 0, SZ_CMD);
    while (1) {		/* loop until timeout		*/

	/*  Write the interactive prompt to the screen.
	 */
        if ((interact || fd == stdin) && !use_ipc)
	    fprintf (stderr, "vosamp> ");

	/*  Initialize the input file descriptor set.
	 */
	fds = allset;
      	if (select (32, &fds, NULL, NULL, &tm) == 0) {
	    read_timeout++;		/* input timeout	    */
	    unlink (dotfile); 		/* clean up the dotfile     */
       	    vos_sampShutdown ();	/* shutdown Hub connection  */
	    return;
	}

	if (use_ipc) {
	    int  nbytes = 0, nread = 0, type = 0, mode = 0;


       	    /* Accept a connection on the port.
       	     */
	    memset (line, 0, SZ_CMD);
       	    if ((ipc_sock = accept (svr_sock, NULL, NULL)) < 0)
       		fprintf (stderr, "accept() errno %d: %s", 
		    errno, strerror(errno));

	    vos_sockReadHdr (ipc_sock, &nbytes, &type, &mode);
	    nread = vos_sockRead (ipc_sock, line, nbytes);

	} else { 
	    if (fgets (line, SZ_CMD, fd) == NULL)
	        break;
	}

	/*  Kill trailing ws.
	 */
	if (isspace(line[strlen(line)-1]))
	    line[strlen(line)-1] = '\0';   

	memset (cmd, 0, SZ_CMD);
	for (i=0; i < MAX_ARGS; i++)
   	    memset (args[i], 0, SZ_LINE);

	if (strncasecmp (line, "exec", 4) == 0 ||
	    strncasecmp (line, "echo", 4) == 0) {
	        /*  Special-case for exec/echo cmd to create single arg
	         */
	        strncpy (cmd, line, 4);
	        sprintf (args[0], "%s", &line[5]);
	        numargs = 1;

	} else {
       	    numargs = sscanf (line, "%s %s %s %s %s %s %s %s %s", 
	        cmd, args[0], args[1], args[2], args[3], 
	           args[4], args[5], args[6], args[7]);
	}

	/*  Process the input command.
	 */
	vos_procCmd (sampH, to, cmd, args, numargs);

	if (use_ipc)
	    close (ipc_sock); 		/*  close the socket descriptor  */

        memset (line, 0, SZ_CMD);	/* clear the input buffer	 */
    }
    if (fd != stdin)
	fclose (fd);
}



/**
 *  USAGE --  Print a task usage summary.
 */
static void
Usage (void)
{ 
 fprintf (stderr,
 "  Usage:\n"
 "\n" 
 "	%% vosamp [-hvd] [-t to] [-p pattern] [-f file] <cmd> [args ...]\n" 
 "\n" 
 "  	where	<cmd>			command to process\n" 
 "  	     	-h			print help summary\n" 
 "  	     	-v			verbose output\n" 
 "  	     	-d			debug output\n" 
 "\n" 
 "  	     	-m			handle multiple messages\n"
 "  	     	-s <sender>		handly only msgs from <sender>\n"
 "\n" 
 "  	     	-t <to>			send to specified app (or all)\n" 
 "  	     	-p <pattern>		message pattern:  sync|async|notify\n" 
 "  	     	-f <file>		send all commands in the file\n" 
 "\n" 
 "  Commands:\n" 
 "\n" 
 "    snoop 				    print all received messages\n"
 "    send <mtype> [<args> ...]		    generalized <mtype> message send\n" 
 "\n" 
 "    status 				    print Hub availability\n" 
 "    list 				    list all registered clients\n"
 "    access <appName>			    print <appName> availability\n" 
 "    handle <mtype>			    wait for <mtype> message\n" 
 "\n" 
 "    exec <cmd>			    execute a client command\n" 
 "    setenv  <name> <value>		    set an environment value\n" 
 "    getenv  <name>			    get an environment value\n" 
 "    setparam <name> <value>		    set a parameter value\n" 
 "    getparam <name>			    get a parameter value\n" 
 "\n" 
 "    load <url>			    load the image/table\n" 
 "    loadImage <url>			    load the named image\n" 
 "    loadVOTable <url>			    load the named VOTable\n" 
 "    loadFITS <url>			    load the named FITS bintable\n" 
 "    loadSpec <url>			    load the named spectrum\n" 
 "    loadResource <ivorn>		    load the named VO Resource\n" 
 "\n" 
 "    pointAt <ra> <dec>		    point at given coords\n" 
 "    showRow [<url>] [<tblId>] <row>	    highlight specified row\n" 
 "    selectRows [<url>] [<tblId>] <rows>   select specified rows\n" 
 "    bibcode <bibcode> 		    load the bibcode\n"
 "\n" 
 );
}



/**
 *  Tests -- Task unit tests.
 */
static void
Tests (char *input)
{
   vo_taskTest (self, "--help", NULL);
   vo_taskTest (self, input, NULL);
   vo_taskTest (self, "-n", input, NULL);
   vo_taskTest (self, "-o", "-", input, NULL);
}


/**
 *  VOS_DOTFILE -- Create a pathname to the .vosamp file indicating a 
 *  running local proxy server.
 */
static char *
vos_dotFile ()
{
    static char dotfile[SZ_FNAME];
    static int  initialized = 0;

    if (! initialized) {
        char   *home = NULL;

        if ((home = getenv ("HOME")) == NULL)
	    home = "./";
        memset (dotfile, 0, SZ_FNAME);
        sprintf (dotfile, "%s/.vosamp", home);
    }
    initialized++;

    return (dotfile);
}


/**
 *  VOS_SAMPINIT -- Initialize the SAMP/Proxy interface connection.
 */
static void
vos_sampInit (void)
{
    FILE *df;


    /*  Initialize the SAMP interface.
    */
    sampH = sampInit ("vosamp", "VOClient SAMP Task");

    /*  Set alternative messaging pattern if requested. Valid values are
     *  'synch', 'asynch' or 'notify'.
     */
    if (pattern) {
	switch (tolower(pattern[0])) {
	case 's':  samp_setSyncMode (sampH);	break;	    /* default 	*/
	case 'a':  samp_setASyncMode (sampH);	break;
	case 'n':  samp_setNotifyMode (sampH);	break;
	default:
	    if (verbose)
		fprintf (stderr, "Warning: Invalid pattern '%s'\n", pattern);
	}
    } else {
        /*  Use Synchronous mode by default so we don't exit before receiving
         *  the reply.  Otherwise, we could cause an error in the recipient.
         */
        samp_setSyncMode (sampH);
    }

    /*  If we're not sending to a specific client, disable the name mapping
     *  to speed up the connection.
    if (strncmp (to, "all", 3) == 0)
	samp_setOpt (sampH, "mapClients", 0);
     */

    samp_Metadata (sampH, "author.name",   "Mike Fitzpatrick, NOAO");
    samp_Metadata (sampH, "author.email",  "fitz@noao.edu");
    samp_Metadata (sampH, "samp.icon.url",
        "http://iraf.noao.edu/images/iraf-icon.gif");
    samp_Metadata (sampH, "samp.description.html",
        "http://iraf.noao.edu/~fitz/voclient/vosamp.html");
    samp_Metadata (sampH, "samp.icon.url", 
	"http://iraf.noao.edu/~fitz/voclient/vao_icon.gif");

    /*  If we're in session mode, subscribe to all message types.  The
     *  same handler is used to pass on the message to other clients in
     *  the session.
     */
    if (session_sock) {
	register int i = 0;
	static char *mtypes[] = {
          "samp.app.ping",   	"samp.app.event.*", 	"samp.hub.event.*",
          "image.load.fits", 	"table.highlight.row", 	"table.load.fits",
          "table.load.votable", "table.select.rowList", "client.cmd.exec",
          "client.param.set", 	"client.param.get", 	"client.env.set",
          "client.env.get", 	"voresource.loadlist", 	"coord.pointAt.sky",
	  "bibcode.load", 	"spectrum.load.*", 
	  NULL
	};

	while (mtypes[i++])
            samp_Subscribe (sampH, mtypes[i],  vos_sessionHandler);
    }


    /*  Register with the Hub and begin messaging.
     */
    sampStartup (sampH);


    /*  Write the dotfile.
     */
    if (!interact && (df = fopen (vos_dotFile(), "w+")) != (FILE *) NULL) {
	fprintf (df, "%s  %d  %ld\n", vos_getLocalIP(), port,
	    (long) (time((time_t)0) + timeout));
	fclose (df);
    }
}


/**
 *  VOS_SAMPSHUTDOWN -- Shutdown the SAMP/Proxy interface connection.
 */
static void
vos_sampShutdown (void)
{
    if (sampShutdown (sampH) < 0) 			/*  clean up 	*/
	fprintf (stderr, "SAMP shutdown fails\n");
    sampClose (sampH);
}


/**
 *  VOS_SESSIONHANDLER -- Generic session message-forwarding handler.
 */
static int
vos_sessionHandler (char *sender, char *mtype, char *msg_id, Map map)
{
    /*  Not yet implemented  */

    return (0);
}


/**
 *  VOS_PROCCMD -- Process the command and its arguments.
 */
static void
vos_procCmd (int sampH, char *to, char *cmd, char *args[], int numargs)
{
    int   i, reslen = 0, stat = OK;
    char *result = NULL;
    char buf[SZ_BUF];



    /*  Print command help.
     */
    if (strncmp (cmd, "?", 1) == 0) {
	Usage ();
	return;
    }
    if (strncmp (args[0], "?", 1) == 0) {
	vos_cmdHelp (cmd);
	return;
    }


    /********************************************
     ***         VOSAMP Custom Commands        **
     ********************************************/
    if (MATCH ("status")) {
	stat = (sampH >= 0);

    } else if (MATCH ("handle")) {
	int timeout = (atoi (args[1]) == 0 ? 999999 : atoi (args[1]));

	if (verbose)
	    fprintf (stderr, "Waiting for '%s' ....\n", args[0]);
	if (*args[1])
	    filt_sender = args[1];

	samp_Subscribe (sampH, (filt_mtype = args[0]), vos_msgHandler);
    	samp_DeclareSubscriptions (sampH);
	sleep (timeout);

    } else if (MATCH ("snoop")) {
        /*  Subscribe to all message types and install the snoop handler.
         *  Sleep forever so the handler can print anything it receives.
         */
	multiple = 1;
        samp_Subscribe (sampH, "*",  vos_msgHandler);
    	samp_DeclareSubscriptions (sampH);
	sleep (9999999);

    } else if (MATCH ("send")) {
	if (strcasecmp (to, "all"))	/* no recipient, use broadcast */
	    samp_setASyncMode (sampH);
        stat = samp_sendGeneric (sampH, to, args[0], &args[1]);

    } else if (MATCH ("echo")) {     			/* ECHO 	      */
	for (i=0; i < numargs; i++)
	    printf ("%s ", args[i]);
	printf ("\n");


    } else if (MATCH ("start")) {     			/* START 	      */
	if (!use_ipc)
            printf ("Starting SAMP interface .....\n");
        sampStartup (sampH);

    } else if (MATCH ("stop")) {      			/* STOP 	      */
        if (!use_ipc)
	    printf ("Stopping SAMP interface .....\n");
        sampShutdown (sampH);

    } else if (MATCH ("help")) {      			/* HELP 	      */
        Usage ();

    } else if (MATCH ("quit")) {                   	/* QUIT 	      */
        if (sampShutdown (sampH) < 0) {
	    if (!use_ipc)
                fprintf (stderr, "Shutdown fails\n");
	}
        sampClose (sampH);
	unlink (vos_dotFile());
        exit (0);

    } else if (MATCH ("trace")) {          		/* TRACE 	      */
        xml_trace++;
        if (xml_trace % 2)
            setenv ("XMLRPC_TRACE_XML", "1", 1);
        else
            unsetenv ("XMLRPC_TRACE_XML");

    } else if (MATCH ("listClients")) {         	/* LIST CLIENTS	      */
	char *clist = NULL;

	samp_mapClients (sampH);
        clist = samp_getClients (sampH);
	if (use_ipc) {
	    reslen = strlen (clist);
	    result = strdup (clist);
	} else
	    printf ("Clients:\n%s", clist);
	


    /********************************************
     ***      Hub Administrative Messages     ***
     ********************************************/
    } else if (MATCH ("ping")) {		/* samp.app.ping 	      */
        stat = samp_Ping (sampH, "Hub");



    /********************************************
     ***    Client Administrative Messages    ***
     ********************************************/
    } else if (MATCH ("ping")) {		/* samp.app.ping 	      */
        stat = samp_Ping (sampH, to);

    } else if (MATCH ("access")) {		/* samp.app.ping 	      */
        stat = samp_Ping (sampH, to);



    /********************************************
     ***    Table/Image Load Message Types    ***
     ********************************************/
						/* image.load.fits 	      */
    } else if (MATCH ("loadImage") || MATCH ("loadFITS")) {
        stat = samp_imageLoadFITS (sampH, to, 
		vos_toURL (args[0]),	/* URL/file 	*/
		vos_optArg (args[1]), 	/* imgId	*/
		vos_optArg (args[2]));	/* name		*/

    } else if (MATCH ("loadVOTable")) {		/* table.load.votable 	      */
        stat = samp_tableLoadVOTable (sampH, to, 
		vos_toURL (args[0]), 	/* URL/file 	*/
		vos_optArg (args[1]), 	/* tblId	*/
		vos_optArg (args[2]));	/* name		*/

    } else if (MATCH ("load")) {
	extern int vot_fileType();

	switch (vot_fileType (args[0])) {
	case VOT_FITS:
            stat = samp_imageLoadFITS (sampH, to, 
		vos_toURL (args[0]),	/* URL/file 	*/
		vos_optArg (args[1]), 	/* imgId	*/
		vos_optArg (args[2]));	/* name		*/
	    break;
	case VOT_VOTABLE:
            stat = samp_tableLoadVOTable (sampH, to, 
		vos_toURL (args[0]), 	/* URL/file 	*/
		vos_optArg (args[1]), 	/* tblId	*/
		vos_optArg (args[2]));	/* name		*/
	    break;
	case VOT_FITS_SPEC:
	    break;
	case VOT_VOTABLE_SPEC:
	    break;
	default:
	    if (!use_ipc)
	        fprintf (stderr, "Error: cannot determine file type of '%s'.\n",
		    args[0]);
	}



    /********************************************
     ***        Resource Message Types        ***
     ********************************************/
    } else if (MATCH ("loadResource")) {	/* voresource.loadlist        */
	/*  NYI  */



    /********************************************
     ***         Utility Message Types        ***
     ********************************************/
    } else if (MATCH ("showRow")) {		/* table.highlight.row        */
		/* showRow <url> <row> [<id>]	*/
        stat = samp_tableHighlightRow (sampH, to, 
		vos_optArg (args[2]),	/* table-id 	*/
		vos_toURL (args[0]),	/* URL/file 	*/
		atoi(args[1]));		/* row 		*/
	
    } else if (MATCH ("selectRows")) {		/* table.select.rowList       */
	int  nrows = 0;
	int *rows = vos_toIntArray (args[2], &nrows);

	stat = samp_tableSelectRowList (sampH, to, 
		vos_optArg (args[0]),	/* table-id	*/
                vos_toURL (args[1]),	/* URL/file	*/
		rows,			/* rows[]	*/
		nrows);			/* row 		*/

    } else if (MATCH ("pointAt")) {		/* coord.pointAt.sky          */
        stat = samp_coordPointAtSky (sampH, to, 
		atof(args[0]), 		/* RA		*/
		atof(args[1]));		/* Dec		*/


    /********************************************
     ***     Spectrum Load Message Types      ***
     ********************************************/
    } else if (MATCH ("loadSpec")) {		/* spectrum.load.ssa-generic  */
	/*  FIXME -- meta map not implemented */
	stat = samp_specLoadSSAGeneric (sampH, to, 
		vos_toURL (args[0]),	/* URL		*/
		0, 			/* Map meta	*/  /* NYI */
		vos_optArg (args[2]), 	/* spectrumId	*/
		vos_optArg (args[3]));	/* name		*/


    /********************************************
     ***         Bibcode Message Types        ***
     ********************************************/
    } else if (MATCH ("bibcode")) {		/* bibcode.load	              */
        stat = samp_bibLoad (sampH, to, args[1]);


    /********************************************
     ***         VO/IRAF Message Types        ***
     ********************************************/
    } else if (MATCH ("exec")) {		/* client.cmd.exec    	      */
        samp_cmdExec (sampH, to, args[0]);

    } else if (MATCH ("getenv")) {		/* client.env.get     	      */
        char *v = samp_envGet (sampH, to, 
		args[0]); 		/* name		*/
	if (use_ipc) {
	    reslen = strlen (v);
	    result = strdup (v);
	} else
	    printf ("%s\n", v);
  	free ((void *) v);

    } else if (MATCH ("setenv")) {		/* client.env.set     	      */
        stat = samp_envSet (sampH, to, 
		args[0], 		/* name		*/
		args[1]);		/* value	*/

    } else if (MATCH ("getparam")) {		/* client.param.get   	      */
        char *v = samp_paramGet (sampH, to, 
		args[0]); 		/* name		*/
	if (use_ipc) {
	    reslen = strlen (v);
	    result = strdup (v);
	} else
	    printf ("%s\n", v);
  	free ((void *) v);

    } else if (MATCH ("setparam")) {		/* client.param.set           */
        stat = samp_paramSet (sampH, to, 
		args[0], 		/* name		*/
		args[1]);		/* value	*/


    /********************************************
     ***            Unknown Command           ***
     ********************************************/
    } else {
	if (use_ipc) {
	    memset (buf, 0, SZ_BUF);
	    sprintf (buf, "Error: unknown command '%s'\n", cmd);
	    result = strdup (buf);
	    reslen = strlen (buf);
	} else
	    fprintf (stderr, "Error: unknown command '%s'\n", cmd);
    }


    if (verbose) {
        if (use_ipc) {
	    result = strdup ((stat < 0 ? "Error" : "OK"));
	    reslen = strlen (result);
        } else
            fprintf (stderr, "%s\n", (stat < 0 ? "Error" : "OK"));
    }
    if (debug)
	fprintf (stderr, "procCmd: reslen=%d  result='%s'\n", reslen, result);
	

    /*  Return result to the remote caller.
     */
    if (use_ipc) {
	vos_sockWrite (ipc_sock, &reslen, sizeof(int));
        if (reslen) {
	    vos_sockWrite (ipc_sock, result, reslen);
	    free (result);
	}
    }
}


/**
 *  VOS_CMDHELP -- Print a command help summary for interactive mode.
 */
static void
vos_cmdHelp (char *cmd)
{
    if (MATCH ("status")) {
	printf ("status\n");
    } else if (MATCH ("handle")) {
	;
    } else if (MATCH ("snoop")) {
	printf ("snoop\n");
    } else if (MATCH ("send")) {
	;
    } else if (MATCH ("start")) {
	printf ("start\n");
    } else if (MATCH ("stop")) {
	printf ("stop\n");
    } else if (MATCH ("echo")) {
	printf ("echo <text_string>\n");
    } else if (MATCH ("help")) {
	printf ("help <cmd>\n");
    } else if (MATCH ("quit")) {
	printf ("quit\n");
    } else if (MATCH ("trace")) {
	printf ("trace\n");
    } else if (MATCH ("listClients")) {
	printf ("listClients\n");
    } else if (MATCH ("ping")) {
	printf ("ping <appName>\n");
    } else if (MATCH ("access")) {
	printf ("access <appName>\n");

    } else if (MATCH ("loadImage") || MATCH ("loadFITS")) {
	printf ("loadImage <file | URL> [<table-id> [<name>]]\n");
    } else if (MATCH ("loadVOTable")) {
	printf ("loadVOTable <file | URL> [<table-id> [<name>]]\n");
    } else if (MATCH ("loadResource")) {
	;
    } else if (MATCH ("showRow")) {
	printf ("showRow <table-id> <file | URL> <row>\n");
    } else if (MATCH ("selectRows")) {
	printf ("selectRows <table-id> <file | URL> <rowList>\n");

    } else if (MATCH ("pointAt")) {
	printf ("pointAt <ra> <dec>\t# coords in decimal degrees\n");

    } else if (MATCH ("loadSpec")) {
	printf ("loadSpec <URL> <meta> [<spectrum-id> <name>]\n");
    } else if (MATCH ("bibcode")) {
	printf ("bibcode <bibcode>\n");

    } else if (MATCH ("exec")) {
	printf ("exec <cmd_str>\n");
    } else if (MATCH ("getenv")) {
	printf ("getenv <name>\n");
    } else if (MATCH ("setenv")) {
	printf ("setenv <name> <value>\n");
    } else if (MATCH ("getparam")) {
	printf ("getparam <name>\n");
    } else if (MATCH ("setparam")) {
	printf ("setparam <name> <value>\n");
    }
}


/**
 *  VOS_OPTARG -- Input command arguments are allowed to be of the form
 *  'param=value', but the SAMP interface only wants the value string. 
 *  Skip past the '=' and return the value, or just return the value if
 *  there is no parameter name.
 */
static char *
vos_optArg (char *arg)
{
    char *ip, first = (arg ? *arg : 0);

    if (!arg || !first) return ("");
    return ( ((ip = strchr (arg, (int) '=')) ? ++ip : arg) );
}


/**
 *  VOS_TOURL -- Convert the argument to a URL suitable for a message.
 */
static char *
vos_toURL (char *arg)
{
    /*  If we have an existing protocol simply return the argument.
     */
    if ((strncmp (arg, "http:", 5) == 0) ||
        (strncmp (arg, "file:", 5) == 0) ||
        (strncmp (arg, "ftp:", 4) == 0))
    	    return (arg);

    if (access (arg, F_OK) == 0) {
	char  cwd[SZ_FNAME];
	static char buf[SZ_FNAME];

 	memset (cwd, 0, SZ_FNAME);
	getcwd (cwd, (unsigned long) SZ_FNAME);

 	memset (buf, 0, SZ_FNAME);
	sprintf (buf, "file://%s/%s", cwd, arg);

	return (buf);
    }

    return (arg);
}


/**
 *  VOS_TOINTARRAY -- Convert a range string to an unpacked array of ints.
 */
#define MAX_RANGES	 256
#define SZ_ROW		  16

static int *
vos_toIntArray (char *arg, int *nrows)
{
    int  i, val, nvalues;
    static int  ranges[MAX_RANGES], values[MAX_ROWS];
    extern int  vot_decodeRanges(), get_next_number();


    memset (values, 0, (sizeof(int) * MAX_ROWS));
    memset (ranges, 0, (sizeof(int) * MAX_RANGES));

    if (vot_decodeRanges (arg, ranges, MAX_RANGES, &nvalues) < 0)
        fprintf (stderr, "Error decoding range string.\n");

    for (i=0, val=0; (val = get_next_number (ranges, val)) > 0; i++ )
	values[i] = val;

    *nrows = nvalues;
    return (values);
}


/**
 *  VOS_MSGHANDLER -- Incoming message handler.
 */
static void 
vos_msgHandler (char *sender, char *msg_id, int params)
{
    if (filt_sender && strcasecmp (filt_sender, sender))
        return;

    /*  Either no filters were set, or the message is of the requested type,
     *  print the contents.
     */
    samp_printMessage (filt_mtype, samp_id2app (sampH, sender), msg_id, params);

    if (!interact && !multiple) { 	/*  Do a clean disconnect ....	*/
        if (sampShutdown (sampH) < 0)
	    fprintf (stderr, "SAMP shutdown fails\n");
        sampClose (sampH);
        exit (0);
    }
}


/*****************************************************************************
****  Socket Utilities
*****************************************************************************/



#define	SELWIDTH	32
#define	SOCK_MAX_TRY	 8
#define	DEBUG		 0

/** 
 *  vos_openServerSocket -- Open a socket to be used on the 'server' side.
 *
 *  @brief  Open a socket to be used on the 'server' side
 *  @fn     int vos_openServerSocket (int port)
 *
 *  @param  port	port number to open
 *  @return		socket descriptor
 *
 */
static int
vos_openServerSocket (int port)
{
    struct  sockaddr_in servaddr; 	/* server address 		*/
    int     ps = 0;                    	/* parallel socket descriptor	*/
    int32_t yes = 1, ntries = 5;


    /* Create a socket.
    */
    if ((ps = socket (AF_INET, SOCK_STREAM, 0)) < 0) {
	fprintf (stderr, "openServerSocket(%d): %s\n", errno, strerror(errno));
	return (-1);
    }
    setsockopt (ps, SOL_SOCKET, SO_REUSEADDR, (void *)&yes,   sizeof(yes));

    if (DEBUG)
	fprintf (stderr, "server socket %d on %s:%d\n", ps, 
	    vos_getLocalIP(), port );


    /* Set server address.
    */
    memset (&servaddr, 0, sizeof servaddr);
    servaddr.sin_family      = AF_INET;
    servaddr.sin_port        = htons(port);
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    /* Bind to the server socket and listen for a connection.
    */
    while (ntries--) {
        if (bind (ps, (struct sockaddr*)&servaddr, sizeof servaddr) < 0) {
	    if (!ntries)
	        return (-1);
        } else {
            if ((listen (ps, SOMAXCONN)) < 0) {
                fprintf (stderr, 
		    "serverSock: listen(%d:%s)", port, strerror(errno));
	        if (!ntries)
	            return (-1);
            } else { 
	        break;
            }
	}
	sleep (1);
    }

    return (ps);
}


/** 
 *  vos_openClientSocket -- Open a socket to be used on the 'client' side.
 *
 *  @brief  Open a socket to be used on the 'client' side
 *  @fn     int vos_openClientSocket (char *host, int port, int retry)
 *
 *  @param  host	host name
 *  @param  port	port number to open
 *  @param  retry	attempt to reconnect?
 *  @return		socket descriptor
 *
 */
static int
vos_openClientSocket (char *host, int port, int retry)
{
    char    *ip, lhost[SZ_LINE];
    struct  sockaddr_in servaddr; 	/* server address 		*/
    int     ps = 0;                    	/* parallel socket descriptor	*/
    socklen_t ctry = 0, yes = 1;


    /* Remove any server port information from the host specification.
    */
    memset (lhost, 0, SZ_LINE);
    strcpy (lhost, host);
    if ( (ip = strchr (lhost, (int) ':')) )
	*ip = '\0';

    /* Create a socket.
    */
    if ((ps = socket (AF_INET, SOCK_STREAM, 0)) < 0) {
	fprintf (stderr, "openClientSocket(%d): %s\n", errno, strerror(errno));
	return (-1);
    }
    setsockopt (ps, SOL_SOCKET, SO_REUSEADDR, (void *)&yes,   sizeof(yes));


    /* Set server address.
    */
    memset (&servaddr, 0, sizeof (struct sockaddr_in));
    servaddr.sin_family      = AF_INET;
    servaddr.sin_port        = htons(port);

    /* Connect to server.
    */
    for (ctry = (retry ? 0 : SOCK_MAX_TRY); ctry <= SOCK_MAX_TRY; ctry++) {

        if ( !inet_aton(lhost, &servaddr.sin_addr) ) {
	    struct hostent *he = vos_getHostByName ( lhost );

            if (!he) {
                fprintf (stderr, "Cannot resolve address.\n");
                exit (2);
            }
            if (he->h_addrtype != AF_INET || 
	        he->h_length != sizeof (servaddr.sin_addr)) {
                    fprintf (stderr, "Cannot handle addr type %d, length %d.\n",
                        he->h_addrtype, he->h_length);
                    exit(2);
            }
            memcpy (&servaddr.sin_addr, he->h_addr_list[0], 
	        sizeof (servaddr.sin_addr) );
        }

        if (connect (ps, (struct sockaddr *)&servaddr, sizeof servaddr) < 0) {
	    if (!retry || ctry == SOCK_MAX_TRY) {
	        fprintf (stderr, 
		    "client connect() failed to %s:%d, try %d, retry %d\n", 
		    lhost, port, ctry, retry);
	        close (ps);
		ps = -1;
		break;
	    } else
	        sleep (1);
        } else
	    break;
    }

    return (ps);
}


/**
 *  VOS_SOCKWRITEHDR -- Write the socket message header.
 */
static void
vos_sockReadHdr (int fd, int *len, int *type, int *mode)
{
    int   nread = 0;

    memset (&msgHdr, 0, sizeof (msgHdr));
    nread = vos_sockRead (fd, &msgHdr, sizeof (msgHdr));

    *len  = msgHdr.nbytes;
    *type = msgHdr.type;
    *mode = msgHdr.mode;
    if (msgHdr.type == SAMP_CMD) {
        to = strdup (msgHdr.recipient);
        strcpy (senderIP, msgHdr.senderIP);
    }
}


/**
 *  VOS_SOCKWRITEHDR -- Write the socket message header.
 */
static void
vos_sockWriteHdr (int fd, int len, int type, int mode, char *to)
{
    int  nwrite = 0;

    memset (&msgHdr, 0, sizeof (msgHdr));
    msgHdr.nbytes = len;
    msgHdr.type = type;
    msgHdr.mode = mode;
    strcpy (msgHdr.recipient, to);
    strcpy (msgHdr.senderIP, vos_getLocalIP());

    nwrite = vos_sockWrite (fd, &msgHdr, sizeof(msgHdr));
}


/**
 *  VOS_SOCKREAD -- Read exactly "n" bytes from a socket descriptor. 
 *
 *  @brief  Recv exactly "n" bytes from a socket descriptor. 
 *  @fn     int vos_sockRead (int fd, void *vptr, int nbytes)
 *
 *  @param  fd          file descriptor
 *  @param  vptr        data buffer to be written
 *  @param  nbytes      number of bytes to write
 *  @return             number of bytes written
 */
static int
vos_sockRead (int fd, void *vptr, int nbytes)
{
    char    *ptr = vptr;
    int     nread = 0, nleft = nbytes, nb = 0;
    fd_set  allset, fds;


    /*  Set non-blocking mode on the descriptor.
     */
    vos_setNonBlock (fd);

    FD_ZERO (&allset);
    FD_SET (fd, &allset);

    while (nleft > 0) {
      fds = allset;
      if (select (SELWIDTH, &fds, NULL, NULL, NULL)) {
        if ( (nb = recv (fd, ptr, nleft, 0)) < 0) {
            if (errno == EINTR || errno == EAGAIN)
                nb = 0;             /* and call recv() again */
            else {
		fprintf (stderr, "vos_sockRead: %s\n", strerror (errno));
                return (-1);
	    }
        } else if (nb == 0)
            break;                  /* EOF */
        nleft -= nb;
        ptr   += nb;
        nread += nb;
      }
    }

    return (nread);                 /* return no. of bytes read */
}


/**
 *  VOS_SOCKWRITE -- Write exactly "n" bytes to a socket descriptor. 
 *
 *  @brief  Send exactly "n" bytes to a socket descriptor. 
 *  @fn     int vos_sockWrite (int fd, void *vptr, int nbytes)
 *
 *  @param  fd          file descriptor
 *  @param  vptr        data buffer to be written
 *  @param  nbytes      number of bytes to write
 *  @return             number of bytes written
 */
static int
vos_sockWrite (int fd, void *vptr, int nbytes)
{
    char    *ptr = vptr;
    int     nwritten = 0,  nleft = nbytes, nb = 0;
    fd_set  allset, fds;


    /*  Set non-blocking mode on the descriptor.
     */
    vos_setNonBlock (fd);

    FD_ZERO (&allset);
    FD_SET (fd, &allset);

    while (nleft > 0) {
      fds = allset;
      if (select (SELWIDTH, NULL, &fds, NULL, NULL)) {
        if ( (nb = send (fd, ptr, nleft, 0)) <= 0) {
            if (errno == EINTR || errno == EAGAIN)
                nb = 0;             /* and call send() again */
            else {
		fprintf (stderr, "vos_sockWrite: %s\n", strerror (errno));
                return (-1);
	    }
        }
        nleft    -= nb;
        ptr      += nb;
        nwritten += nb;
      }
    }

    return (nwritten);
}


/**
 *  VOS_SETNONBLOCK -- Set a non-blocking mode on the socket descriptor.
 */
static void
vos_setNonBlock (int sock)
{
    int flags;


    /* Set socket to non-blocking.
    */
    if ((flags = fcntl (sock, F_GETFL, 0)) < 0) {
        /* Handle error */
        return;
    }
    if (fcntl (sock, F_SETFL, flags | O_NONBLOCK) < 0) {
        /* Handle error */
        return;
    }
}


/**
 *  VOS_GETLOCALIP -- Get the IP address of the local machine.
 */
static char *
vos_getLocalIP (void)
{
    const char *kGoogleDnsIp = "8.8.8.8";  /* Google's public DNS server */
    unsigned short kDnsPort  = 53;
    struct sockaddr_in serv;
    int    sock, err;
    const  char *p;
    char   buffer[SZ_BUF];
    static int initialized = 0;
    static char localIP[SZ_BUF];


    /*  Only get the IP once, afterwards just return the value.
     */
    if (initialized++)
	return (localIP);

    memset (buffer, 0, SZ_BUF);
    memset (localIP, 0, SZ_BUF);

    if ((sock = socket (AF_INET, SOCK_DGRAM, 0)) < 0)
        return ("127.0.0.1");   /* cannot get socket, punt     */

    memset (&serv, 0, sizeof (serv));
    serv.sin_family = AF_INET;
    serv.sin_addr.s_addr = inet_addr(kGoogleDnsIp);
    serv.sin_port = htons(kDnsPort);

    if ((err = connect(sock, (struct sockaddr*)&serv, sizeof(serv))) >= 0) {
        struct sockaddr_in name;
        socklen_t namelen = sizeof(name);

        if ((err=getsockname(sock, (struct sockaddr*)&name, &namelen)) < 0)
            strcpy (buffer, "127.0.0.1");       /* cannot connect socket  */
        else
            if ((p=inet_ntop(AF_INET, &name.sin_addr, buffer, SZ_BUF)) == NULL)
                strcpy (buffer, "127.0.0.1");   /* cannot get IP buffer name */
    } else
        strcpy (buffer, "127.0.0.1");   /* cannot get IP buffer name */

    close(sock);

    strcpy (localIP, buffer);
    return (localIP);
}


/**
 *  VOS_GETHOSTBYNAME -- Get the host entry associated with a (cached) name.
 *
 *  @fn   char *vos_getHostByName (char *name)
 *
 *  @param  name 	host name
 *  @return 		host entry structure pointer
 */
typedef struct {
    char   name[SZ_LINE];
    char   ip[SZ_LINE];
    struct hostent *host;
}  hostTab, *hostTabP;

struct hostent_wrapper {
    struct hostent hentry;
    int    status;
};

static hostTab hostab[MAX_CLIENTS];


static struct hostent *
vos_getHostByName (char *name)
{
    static int initialized = 0;
    struct in_addr x_addr;
    struct hostent *hp = (struct hostent *) NULL;
    hostTab  *h = (hostTabP) hostab;
    int    i, len;


    if (!initialized) {
	memset (hostab, 0, sizeof (hostab));
	initialized++;
    }

    for (i=0; i < MAX_CLIENTS; i++, h++) {
	if (h && h->name[0]) {
	    len = min (strlen (name), strlen (h->name));
	    if (strncmp (name, h->name, len) == 0)
		return (h->host);
	} else 
	    break;				/* end of cache list */
    }

    /*  If we overflow the cache use a DNS lookup.
     */
    if (i >= MAX_CLIENTS) {
	fprintf (stderr, "vos_getHostByName(): cache overflow on '%s'", name);
        hp = gethostbyname (name);
        return (hp);
    }

    /*  Host not found, resolve and add it to the cache.
     */
    hp = gethostbyname (name);
    if (hp == (struct hostent *) NULL) {
	fprintf (stderr, "vos_getHostByName: cannot resolve '%s'\n", name);
	exit (0);
    }

    strcpy (h->name, name);
    x_addr.s_addr = *((unsigned long *) hp->h_addr_list[0]);
    strcpy (h->ip,   inet_ntoa (x_addr));

    h->host = vos_dupHostent (hp); 
    return (h->host);
}


/**
 *   VOS_DUPHOSTENT -- Duplicate a hostent structure via a deep copy.
 */
static struct hostent *
vos_dupHostent (struct hostent *hentry)
{
    struct hostent_wrapper *oldhw = NULL;
    struct hostent_wrapper *newhw = NULL;
    int i = 0;
    int aliascount=0;
    int addrcount=0;

	
    if (!hentry)
    	return NULL;

    oldhw = (struct hostent_wrapper *) hentry;
    newhw = (struct hostent_wrapper *) malloc (sizeof (struct hostent_wrapper));
    bzero(newhw, sizeof (struct hostent_wrapper));

    newhw->hentry.h_addrtype = hentry->h_addrtype;
    newhw->hentry.h_length = hentry->h_length;
    newhw->status = oldhw->status;

    if (hentry->h_name)
    	newhw->hentry.h_name = strdup(hentry->h_name);

    if (hentry->h_aliases) {
    	for (i=0; hentry->h_aliases[i] != 0; i++)
    	    aliascount++;
    	aliascount++;

	newhw->hentry.h_aliases = (char **)malloc (aliascount * sizeof (char*));
	bzero(newhw->hentry.h_aliases, aliascount * sizeof(char*));

	for (i=0; hentry->h_aliases[i] != 0; i++) {
	    if (hentry->h_aliases[i])
		newhw->hentry.h_aliases[i] = strdup (hentry->h_aliases[i]);
	}
    }
	
    if (hentry->h_addr_list) {
	for (i=0; hentry->h_addr_list[i] != 0; i++)
	    addrcount++;
	addrcount++;
		
	newhw->hentry.h_addr_list = 
	    (char **) malloc (addrcount * sizeof (char *));
	bzero (newhw->hentry.h_addr_list, addrcount * sizeof (char *));
		
	for (i=0; hentry->h_addr_list[i] != 0; i++) {
	    if (hentry->h_addr_list[i])
		newhw->hentry.h_addr_list[i] = strdup (hentry->h_addr_list[i]);
	}
    }

    return (struct hostent *) newhw;
}

